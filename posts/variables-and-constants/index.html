<!doctype html><html class="not-ready lg:text-base overflow-y-scroll scroll-pt-14" lang=en><head prefix="og: https://ogp.me/ns# article: https://ogp.me/ns/article#"><meta charset=utf-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content="Zola v0.21.0" name=generator><title>Variables, Constants, and Naughty Strings | Brian's Logbook</title><meta content="Brian's Logbook" property=og:site_name><meta content="Variables, Constants, and Naughty Strings" property=og:title><meta content="A brief learning note on different types of constants and variables in C++ and Rust." name=description><meta content="A brief learning note on different types of constants and variables in C++ and Rust." property=og:description><meta content=https://blog.brianc.me/posts/variables-and-constants/ property=og:url><link href=https://blog.brianc.me/posts/variables-and-constants/ rel=canonical><meta content=article property=og:type><meta content=2025-04-24T00:00:00+00:00 property=article:published_time><meta content=2025-05-09T00:00:00+00:00 property=article:modified_time><meta content=rust property=article:tag><meta content=cpp property=article:tag><link title="Brian's Logbook | Atom" href=https://blog.brianc.me/atom.xml rel=alternate type=application/atom+xml><link title="Brian's Logbook | RSS" href=https://blog.brianc.me/rss.xml rel=alternate type=application/rss+xml><link href=/favicon.ico rel=icon type=image/x-icon><link href=/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/site.webmanifest rel=manifest><link href="https://blog.brianc.me/styles.css?h=200019d398116bbb090a" as=style rel=stylesheet><link href="https://blog.brianc.me/main.min.css?h=2e89f7f30f1019877d14" rel=stylesheet><style>:root{--bg:#f4f4f5;--header:#e4e4e7;color-scheme:light}:root.dark{--bg:#18181b;--header:#27272a;color-scheme:dark}</style><script src="https://blog.brianc.me/js/linkita.min.js?h=1dd3ed42fc674277bc34"></script><script src="https://blog.brianc.me/js/linkita-search.min.js?h=698547b4b081d012c661"></script><body class="text-black duration-100 ease-out bg-[var(--bg)] dark:text-white"><header class="blur-header fixed top-0 z-40 mx-auto min-h-[3.25rem] w-full header-icons"><div class="mx-auto w-full max-w-4xl p-2.5 lg:flex lg:justify-between"><div class="flex justify-between"><div class="flex items-center min-h-8"><a class="text-2xl font-semibold" title="Go to home page" accesskey=! href=https://blog.brianc.me/>Brian's Logbook</a><button class="btn-dark ml-4 h-6 w-6 shrink-0 cursor-pointer text-[0] bg-center bg-no-repeat bg-cover dark:invert [background-image:var(--icon-theme-dark)] dark:[background-image:var(--icon-theme-light)]" title="Switch color scheme" accesskey=$ onclick=window.linkita.toggleDarkMode(); ondblclick=window.linkita.resetDarkMode(); type=button></button><button class="btn-search ml-4 h-6 w-6 shrink-0 cursor-pointer text-[0] bg-center bg-no-repeat bg-cover [background-image:var(--icon-search)] dark:invert" accesskey=/ onclick=window.linkita.toggleSearch(); title=Search type=button></button><script>window.linkita.initSearchButton({ scripts: ["https://blog.brianc.me/elasticlunr.min.js", "https://blog.brianc.me/search_index.en.js"] });</script></div><div class="btn-menu relative z-50 flex h-8 w-8 shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" onkeydown="(event.keyCode == 13 || event.keyCode == 32) ? event.preventDefault() || window.linkita.toggleHeaderMenu() : true;" accesskey=+ onclick=window.linkita.toggleHeaderMenu(); role=button tabindex=0 title=Menu></div></div><nav class="flex w-full items-center lg:w-auto"><menu class="nav-wrapper flex w-full flex-col py-2 lg:w-auto lg:flex-row lg:self-center lg:py-0"><li><a class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0" href=https://blog.brianc.me/about/>About</a><li><a class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0" href=https://blog.brianc.me/projects/>Projects</a><li><a class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0" href=https://blog.brianc.me/posts/>Archive</a><li><a class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0" href=https://blog.brianc.me/categories/>Categories</a><li><a class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0" href=https://blog.brianc.me/tags/>Tags</a></menu></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-4rem)] max-w-3xl break-words px-4 pb-12 pt-28 lg:pt-32 dark:prose-invert prose-pre:rounded-lg prose-img:rounded-lg"><div class=hidden id=linkita-search-wrapper><ul id=linkita-search-results></ul></div><article><header class=mb-16><h1 class="!my-0 pb-2.5">Variables, Constants, and Naughty Strings</h1><div class="text-sm antialiased opacity-80">Pub <time datetime=2025-04-24T00:00:00+00:00>2025-04-24</time><span class=middot></span>Upd <time datetime=2025-05-09T00:00:00+00:00>2025-05-09</time><span class=middot></span>Est <time datetime=PT0H7M0S>7 min</time><span class=middot></span><a class="no-underline hover:underline" href=https://blog.brianc.me/tags/rust/>#rust</a> <a class="no-underline hover:underline" href=https://blog.brianc.me/tags/cpp/>#cpp</a></div></header><div class="block-bg mb-12 rounded-lg p-2 text-lg"><details><summary accesskey="=" class="select-none py-0.5 lg:py-1 pl-4"><span class=cursor-pointer>Table of Contents</span></summary> <div class=px-2><ul><li><a class="no-underline hover:underline" href=https://blog.brianc.me/posts/variables-and-constants/#rust>Rust</a> <ul><li><a class="no-underline hover:underline" href=https://blog.brianc.me/posts/variables-and-constants/#let-local-variables-mutable-or-immutable>let: Local Variables, Mutable or Immutable</a><li><a class="no-underline hover:underline" href=https://blog.brianc.me/posts/variables-and-constants/#quirky-references>Quirky References</a><li><a class="no-underline hover:underline" href=https://blog.brianc.me/posts/variables-and-constants/#const-constants>const: Constants</a><li><a class="no-underline hover:underline" href=https://blog.brianc.me/posts/variables-and-constants/#static-global-variables-mutable-or-immutable>static: Global Variables, Mutable or Immutable</a></ul><li><a class="no-underline hover:underline" href=https://blog.brianc.me/posts/variables-and-constants/#c>C++</a></ul></div></details></div><section><div class="my-4 flex flex-col rounded-lg bg-[var(--admonition-bg)]" style=--admonition-bg:#00bfa51a><div class="flex items-center rounded-t-lg bg-[var(--admonition-bg)] p-1"><div class="mx-2 h-4 w-4 text-[0] [background:var(--url)_center_center_no-repeat] dark:invert" style=--url:url(./icons/tip.svg)>tip</div><span><strong>Copyright Notice</strong></span></div><div class=pl-4><p>This post is licensed under <a rel="nofollow noreferrer" href=https://creativecommons.org/licenses/by-nc-nd/4.0/>CC BY-NC-ND 4.0</a>.</div></div><p>This note encapsulates some details regarding variables and constants in Rust and C++. Specifically, <code>const</code>, <code>static</code>, <code>let</code> in Rust, and <code>const</code>, <code>auto/int/char/...</code>, <code>constexpr</code> in C++.<p>Additionally there's some extra notes related to <a href=https://blog.brianc.me/posts/variables-and-constants/#quirky-references>references and strings in Rust</a>.<div class="my-4 flex flex-col rounded-lg bg-[var(--admonition-bg)]" style=--admonition-bg:#448aff1a><div class="flex items-center rounded-t-lg bg-[var(--admonition-bg)] p-1"><div class="mx-2 h-4 w-4 text-[0] [background:var(--url)_center_center_no-repeat] dark:invert" style=--url:url(./icons/note.svg)>note</div><span><strong>Nota Bene</strong></span></div><div class=pl-4><p>In this note I'll use Rust's definition for things like "constants", and map C++'s definitions onto Rust's.</div></div><h2 id=rust>Rust</h2><h3 id=let-local-variables-mutable-or-immutable><code>let</code>: Local Variables, Mutable or Immutable</h3><p>See <a rel="nofollow noreferrer" href=https://rust-book.cs.brown.edu/ch03-01-variables-and-mutability.html>TRPL 3.1. Variables and Mutability</a> for details.<p>In Rust, generally we have three types of "values". Mutable variables, immutable variables, and constants. This is different from normal conversation, where the term "variable" implies mutability since, well, the thing "varies".<p>A variable is defined using <code>let</code> with type inference which almost always works. The rare exception is when the compiler has no way of figuring out for sure which type a variable is. An example to this is when using <code>.collect()</code> <sup class=footnote-reference id=fr-1-1><a href=#fn-1>1</a></sup>.<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>let</span><span> a </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>10</span><span>; </span><span style=color:#5c6370>// a: u32
</span><span style=color:#c678dd>let mut</span><span> b: </span><span style=color:#c678dd>&str = </span><span style=color:#98c379>"hello, world"</span><span>;
</span></code></pre><p>By default, these variables are immutable. That is, their value cannot be changed. However, we can "shadow" the variable by declaring another variable of the exact same name. This new variable can be of a different type, different mutability, and different scope.<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#5c6370>// a = 20; // Would fail compilation
</span><span>
</span><span>{
</span><span>    </span><span style=color:#c678dd>let mut</span><span> a </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>20</span><span>;
</span><span>    println!(</span><span style=color:#98c379>"</span><span style=color:#e5c07b>{}</span><span style=color:#98c379>"</span><span>, a); </span><span style=color:#5c6370>// 20
</span><span>    a </span><span style=color:#c678dd>*= </span><span style=color:#e5c07b>10</span><span>; </span><span style=color:#5c6370>// Shadowed a becomes 200
</span><span>} </span><span style=color:#5c6370>// Shadowed a was dropped here
</span><span>
</span><span style=color:#5c6370>// a = 20; // Would still fail compilation
</span><span>println!(</span><span style=color:#98c379>"</span><span style=color:#e5c07b>{}</span><span style=color:#98c379>"</span><span>, a); </span><span style=color:#5c6370>// 10
</span><span>
</span><span style=color:#c678dd>let</span><span> a </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>30</span><span>; </span><span style=color:#5c6370>// Original a no longer accessible
</span><span>println!(</span><span style=color:#98c379>"</span><span style=color:#e5c07b>{}</span><span style=color:#98c379>"</span><span>, a); </span><span style=color:#5c6370>// 30
</span></code></pre><p>It is worth noting that, despite the code examples above, variables defined using <code>let</code> cannot have a global scope - they must exist in functions. Attempting to use <code>let</code> to define a global variable will yield this error message:<pre style=color:#dcdfe4;background-color:#282c34><code><span>`let` cannot be used for global variables
</span><span>help: consider using `static` or `const` instead of `let`
</span></code></pre><p>However, they can exist inside closures used with "lazy static". More on that later.<h3 id=quirky-references>Quirky References</h3><p>In Rust, you can take references to variables (or constants, anything really) and store them inside another variable. Sorta like pointers. I'll skip over stuff related to mutable and immutable references (<code>&</code> and <code>&mut</code>) since that's a whole new topic related to the borrow checker, but here's a quick example:<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>let mut</span><span> c: </span><span style=color:#c678dd>&u32 = &</span><span>a;
</span></code></pre><p>Here, <code>c</code> is a mutable variable holding an immutable reference to <code>a</code>. This means <code>c</code> can be changed to point at another <code>u32</code>, but you cannot modify <code>a</code> through <code>c</code> <sup class=footnote-reference id=fr-2-1><a href=#fn-2>2</a></sup>. <code>c</code> also cannot be changed to point at any variable or constant of any other type (including other integer types), but it can be changed to point at a <code>u32</code> constant.<p>The real quirky stuff comes in when you consider literal strings. In Rust, hardcoded strings are <code>&str</code>, different from <code>String</code>. It's widely known that <code>&str</code> lives on the stack since it has a fixed size, while <code>String</code> lives on the heap since its size is unknown at compile time. However, the reason there's a <code>&</code> here is because <code>b</code> in the first example isn't a string in itself. It's a pointer to the literal string on the stack!<p>Given that <code>b</code> is mutable in the examples above, we can actually do this:<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span>b </span><span style=color:#c678dd>= </span><span style=color:#98c379>"hello! world"</span><span>; </span><span style=color:#5c6370>// Reassigning b to a reference to another literal string on the stack
</span><span>
</span><span style=color:#c678dd>let</span><span> s </span><span style=color:#c678dd>= </span><span>String::from(b);
</span><span>b </span><span style=color:#c678dd>= &</span><span>s[</span><span style=color:#e5c07b>0</span><span style=color:#c678dd>..</span><span style=color:#e5c07b>2</span><span>]; </span><span style=color:#5c6370>// Reassigning b to a string slice, a reference to a String object on the heap
</span></code></pre><h3 id=const-constants><code>const</code>: Constants</h3><p>Constants are something completely different in Rust. They are declared using the <code>const</code> keyword, can <strong>never</strong> be mutable, and have some additional quirks. Their conventional naming is the <code>SCREAMING_CASE</code> and their types must be manually annotated at definition, to name a few.<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>const</span><span> C: </span><span style=color:#c678dd>u32 = </span><span style=color:#e5c07b>100</span><span>;
</span></code></pre><p>Since constants are always immutable, they can be defined in either a local or a global scope, and will always have thread-safe reads. Worth noting that the compiler is permitted to copy them around, and not necessarily reading its content from a fixed memory location.<p>Constants must be known at compile time, and thus only constant expressions are allowed inside. The details for allowed expressions can be found in <a rel="nofollow noreferrer" href=https://doc.rust-lang.org/stable/reference/const_eval.html>The Rust Reference</a>, but in general, basic operations like arthimetic, logical, derefencing, casting, loops, structs/tuples/arrays. Worth noting that things that would normally panic (<em>e.g.</em>, out-of-bound indexing) would now raise a compile error if they are inside a <code>const</code> expression.<p>It is also worth noting that the operations mentioned above (known as "constant expressions") can also be evaluated during compilation when they're in <code>let</code> statements. This doesn't necessarily happen, but the compiler is permitted to do so.<p><code>const</code> is typically used to define actual constants, such as configurations, number of experiments, <em>etc.</em>, within the code for easy access.<h3 id=static-global-variables-mutable-or-immutable><code>static</code>: Global Variables, Mutable or Immutable</h3><p><code>static</code> is usually used to define global variables. Similar to <code>let</code>, they can be mutable, but similar to <code>const</code>, they must have annotated types and the convention is to use all caps.<p>Even though they are called "global variables", they can also be defined within a local scope, such as a function.<p>The reason why it's called "static", is that <code>static</code> items always have only one copy. All references of the object will be pointing at the exact same item. This is not the case for <code>const</code>. In technical terms, <code>static</code> objects have the <code>'static</code> lifetime, and <code>drop</code> is not called on it at the end of the program.<p><code>static</code> is typically used to define application configurations or other variables shared by the entire application. Read-only access to <code>static</code> is thread safe. It is possible to use crates such as <code>once_cell</code> to initialise <code>static</code> objects at runtime startup, so it's often used for things like reading from <code>.env</code> or other configuration paths during runtime. The data will be accessible throughout the entire duration of a program.<p><code>static</code> can be defined as mutable, but that is unsafe due to the potential of data races which will lead to undefined behaviour. It is a common pattern to use <code>static</code> for things like the global state of a web application, in which case you can wrap <code>Mutex</code> inside a <code>static</code> immutable variable like this:<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>use </span><span>std::sync::{LazyLock, Mutex};
</span><span>
</span><span style=color:#c678dd>static </span><span style=color:#e5c07b>ARRAY</span><span>: LazyLock&lt;Mutex&lt;Vec&lt;</span><span style=color:#c678dd>u8</span><span>>>> </span><span style=color:#c678dd>= </span><span>LazyLock::new(|| Mutex::new(vec![]));
</span><span>
</span><span style=color:#c678dd>fn </span><span style=color:#61afef>do_a_call</span><span>() {
</span><span>    </span><span style=color:#e5c07b>ARRAY</span><span>.</span><span style=color:#61afef>lock</span><span>().</span><span style=color:#61afef>unwrap</span><span>().</span><span style=color:#61afef>push</span><span>(</span><span style=color:#e5c07b>1</span><span>);
</span><span>}
</span></code></pre><p>Example provided by <a rel="nofollow noreferrer" href=https://stackoverflow.com/questions/27791532/how-do-i-create-a-global-mutable-singleton>random StackOverflow question</a>.<p>You can call <code>*OTHER_STATIC_VARIABLE</code> inside the closure of another static variable to enforce the order of initilisation.<h2 id=c>C++</h2><p>In C++, <code>const</code> is a modifier just like <code>mut</code> (doing the opposite), and there are no keyword separating local and global variables. They have <code>constexpr</code> instead of <code>const</code> for actual constants, and that's basically it.<p>A few additional quirks:<ul><li>Type inference can be used with <code>constexpr</code> (<code>constexpr auto a = 1;</code>)<li><code>constexpr</code> are immutable just like the Rust constants, so there's no need to write <code>const constexpr</code><li>Similar to Rust's case, constant expressions can be evaluated at compile time even when they are not defined with <code>constexpr</code></ul><p>Simple mapping which is probably not entirely accurate:<table><thead><tr><th>Rust<th>C++<th>Description<th>Thread Safe<th>Evaluated at Compile Time<tbody><tr><td><code>let mut</code><td><code>auto</code>, <code>int</code>...<td>Mutable Local Variable<td>Yes<td>Possible<tr><td><code>static mut</code><sup class=footnote-reference id=fr-3-1><a href=#fn-3>3</a></sup><td><code>auto</code>, <code>int</code>...<td>Mutable Global Variable<td>No<td>Possible<tr><td><code>let</code><td><code>const auto</code><sup class=footnote-reference id=fr-4-1><a href=#fn-4>4</a></sup>, <code>const int</code>...<td>Immutable Local Variable<td>Yes<td>Possible<tr><td><code>static</code><td><code>const auto</code>, <code>const int</code>...<td>Immutable Global Variable<td>Yes<td>Possible<tr><td><code>const</code><td><code>constexpr auto</code><td>Constant<td>Yes<td>Yes, Always</table><p>To achieve "thread-save mutable global variable", in C++ a similar design pattern (as described earlier) involving mutexes is often used.<p>C++, however, will not warn you at all that data races might happen if you define mutable global variables in a multi-threaded context, so if you accidentally do that, it'll probably be a couple hours of painful debugging.<section class=footnotes><ol class=footnotes-list><li id=fn-1><p>You can either specify <code>.collect::&lt;Type>()</code>, in which case the type of the variable is inferred, or specify the type of the variable, in which case the target of the <code>collect</code> method is inferred. <a href=#fr-1-1>↩</a></p><li id=fn-2><p>A mutable reference to <code>a</code> would also be invalid in itself, since <code>a</code> is immutable. <a href=#fr-2-1>↩</a></p><li id=fn-3><p>Only mutations require an <code>unsafe</code> block. <a href=#fr-3-1>↩</a></p><li id=fn-4><p>You can also write this as <code>auto const</code> (less common) but not <code>constexpr auto</code> as <code>auto constexpr</code>. This is because <code>constexpr</code> is a declaration specifier while <code>const</code> is a type qualifier. Declaration specifiers modify type specifiers (<code>auto</code>), hence they must appear in order. Type qualifiers can be anywhere. <a href=#fr-4-1>↩</a></p></ol></section></section><hr><footer class="mt-12 flex flex-col" accesskey=_ tabindex=-1><div class="mb-2 flex flex-wrap"><span class="block-bg mb-1.5 mr-1.5 rounded-lg px-5 py-1.5">Categories</span><a class="block-bg block-hover mb-1.5 mr-1.5 rounded-lg px-5 py-1.5 no-underline" href=https://blog.brianc.me/categories/notes/>Notes</a></div><div class="mb-2 flex flex-wrap"><span class="block-bg mb-1.5 mr-1.5 rounded-lg px-5 py-1.5">Tags</span><a class="block-bg block-hover mb-1.5 mr-1.5 rounded-lg px-5 py-1.5 no-underline" href=https://blog.brianc.me/tags/rust/>rust</a><a class="block-bg block-hover mb-1.5 mr-1.5 rounded-lg px-5 py-1.5 no-underline" href=https://blog.brianc.me/tags/cpp/>cpp</a></div></footer><nav class="block-bg mt-12 flex flex-wrap rounded-lg text-lg"><a class="block-hover-mask ml-auto flex min-w-[50%] grow items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline" accesskey=. href=https://blog.brianc.me/projects/enviame/><span>Enviame - Interim Writeup</span><span class=ml-1.5>›</span></a></nav><div class="giscus mt-12"></div><script data-category="Blog Comments" async crossorigin data-category-id=DIC_kwDOOiBcDc4CpnB7 data-emit-metadata=0 data-input-position=top data-lang=en data-loading=lazy data-mapping=pathname data-reactions-enabled=1 data-repo=differental/blog_html data-repo-id=R_kgDOOiBcDQ data-strict=1 data-theme=preferred_color_scheme src=https://giscus.app/client.js></script></article></main><footer class="mx-auto flex lg:mt-5 max-w-3xl flex-wrap items-center px-4 py-3 text-sm opacity-60"><div class="mr-auto basis-full lg:basis-1/2">© <time datetime=2025>2025</time> Brian Chen | <a href=/copyright>Copyright</a> | <a href=/disclaimer>Disclaimer</a></div><div class="flex basis-full lg:basis-1/2 lg:justify-end"><span class="mr-6 lg:ml-6"> <a class=link href=https://www.getzola.org/ target=_blank>Powered by Zola</a> </span><a class=link href=https://www.getzola.org/themes/linkita/ target=_blank>✎ Linkita</a></div></footer>